 
//###########################################################################
//
// FILE:    MAX7301.c
//
// TITLE:   MAX7301 Initialization & Support Functions.
//
// NOTES:   
//
//###########################################################################
// 
// $Release Date:
//###########################################################################


























#include "PeripheralHeaderIncludes.h"

extern struct  MX7301DAT_REGs Exp1_regs;		//определить регистры устройств SPI
extern struct  MX7301DAT_REGs Exp2_regs;

void Exch_data_SPI(Uint16 device, Uint16* message);

//эта функци€ инициализирует MAX7301 
//----------------------------------------------------------------------
void InitMAX7301(Uint16 device)
{
	int16 i, j=0;
	Uint16 a[2] = {0,0};
	Uint16 data[9];

	//настройка SPI
	SpiaRegs.SPICCR.bit.SPICHAR = 0xF;			//передача слова из 16 бит
	SpiaRegs.SPICCR.bit.CLKPOLARITY = 0;		//подача данных на выход по нарастающему фронту
	SpiaRegs.SPICTL.bit.CLK_PHASE = 1;			//включить задержку сигнала clk
	SpiaRegs.SPIBRR = 9;						//установить частоту LSPCLK/(9+1) (7.5 ћ√ц) 

	//компоновка кодов инициализации	
	data[0] = MX7301_W_code + adr_Cnfg_reg + MX7301_active;	//активировать MX7301
	data[1] = MX7301_W_code + adr_Cnfg_GP7_4 + 0xFF;	 		//настроить порты 4-7 на вход с подт€жкой
	data[2] = MX7301_W_code + adr_Cnfg_GP11_8 + 0xFF;	 		//настроить порты 8-11 на вход с подт€жкой
	data[3] = MX7301_W_code + adr_Cnfg_GP15_12 + 0xFF;	 		//настроить порты 12-15 на вход с подт€жкой
	data[4] = MX7301_W_code + adr_Cnfg_GP19_16 + 0x55;	 		//настроить порты 16-19 на выход
	data[5] = MX7301_W_code + adr_Cnfg_GP23_20 + 0x55;			//настроить порты 20-23 на выход
	data[6] = MX7301_W_code + adr_Cnfg_GP27_24 + 0x55;			//настроить порты 24-27 на выход
	data[7] = MX7301_W_code + adr_GP12_19 + 0xF0;				//установить порты 12-19
	data[8] = MX7301_W_code + adr_GP20_27 + 0xFF;				//установить порты 20-27


	//цикл ожидани€ реакции устройства
	for(i=0;i<9;i++)
		{
		Uint16 q;

		a[j] = data[i];
		Exch_data_SPI(device, &a[j]);
		if((i) & (a[j] != data[i-1])) i = -1;
		j ^= 1;    //инвертировать
		for(q=0;q<10;q++) {};		//задержка
		}
	
}
//-------------------------------------------------------------------------



//эта функци€ обмениваетс€ инф с  MAX7301 
//----------------------------------------------------------------------
void Exch_MAX7301(Uint16 device)
{
	Uint16 a;
	//настройка SPI
	SpiaRegs.SPICCR.bit.SPICHAR = 0xF;			//передача слова из 16 бит
	SpiaRegs.SPICCR.bit.CLKPOLARITY = 0;		//подача данных на выход по нарастающему фронту
	SpiaRegs.SPICTL.bit.CLK_PHASE = 1;			//включить задержку сигнала clk
	SpiaRegs.SPIBRR = 9;						//установить частоту LSPCLK/(9+1) (7.5 ћ√ц) 

	if(device == EXP1_dev_SEL)		
		{
		a = MX7301_R_code + adr_GP4_11;			//команда чтени€ из ports 4-11
		Exch_data_SPI(device, &a);

		a = MX7301_R_code + adr_GP12_19;		//команда чтени€ из ports 12-19
		Exch_data_SPI(device, &a);
		Exp1_regs.GPin.byte.GP4_11 = a & 0xFF;

		a = MX7301_W_code + adr_GP12_19 + Exp1_regs.GPout.byte.GP12_19;	//команда записи в рег 12-19
		Exch_data_SPI(device, &a);
		Exp1_regs.GPin.byte.GP12_19 = a & 0xFF;

		a = MX7301_W_code + adr_GP20_27 + Exp1_regs.GPout.byte.GP20_27;	//команда записи в рег 20-27
		Exch_data_SPI(device, &a);
		}	
	if(device == EXP2_dev_SEL)		
		{
		a = MX7301_R_code + adr_GP4_11;			//команда чтени€ из ports 4-11
		Exch_data_SPI(device, &a);

		a = MX7301_R_code + adr_GP12_19;		//команда чтени€ из ports 12-19
		Exch_data_SPI(device, &a);
		Exp2_regs.GPin.byte.GP4_11 = a & 0xFF;	

		a = MX7301_W_code + adr_GP12_19 + Exp2_regs.GPout.byte.GP12_19;	//команда записи в рег 12-19		
		Exch_data_SPI(device, &a);
		Exp2_regs.GPin.byte.GP12_19 = a & 0xFF;	

		a = MX7301_W_code + adr_GP20_27 + Exp2_regs.GPout.byte.GP20_27;	//команда записи в рег 20-27		
		Exch_data_SPI(device, &a);
		}				
}
//-------------------------------------------------------------------------

