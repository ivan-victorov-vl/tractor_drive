 
//###########################################################################
//
// FILE:    AD7732.c
//
// TITLE:   AD7732 Initialization & Support Functions.
//
// NOTES:   функция InitAD7732(Uint16 device) инициализирует микросхему AD7732 по заданию device,
//			которое определяет устройство. скорость SPI настраивается на 1 Мгц, передача побайтная,
//			для сброса используется кодовая последовательность 00 FF FF FF FF. для запуска АЦП в 
//			непрерывном режиме преобразования потребовалось многократное записывание кода в соответствующие 
//			регистры, иначе не запускается(возможно в будущем что-нибудь придумаю).
//
//			функция read_AD7732(Uint16 device) получает результат от АЦП по заданию device,
//			которое определяет устройство. Результат 16 - битный, передается по половине слова. Записывается в
//			регистры AD7732_1 или AD7732_2 структуры AD7732_RES_REG в зависимости от задания. 
//
//###########################################################################
// 
// $Release Date:
//###########################################################################

#include "PeripheralHeaderIncludes.h"

extern struct	AD7732_RES_REG AD7732_1;		//определить регистры результатов преобразований
extern struct	AD7732_RES_REG AD7732_2;

void Exch_data_SPI(Uint16 device, Uint16* message);

//эта функция инициализирует AD7732 
//----------------------------------------------------------------------
void InitAD7732(Uint16 device)
{
	Uint16  i = 0;
	Uint16	y[5] = {0x0000,0xff00,0xff00,0xff00,0xff00};
	Uint16 data[9];

	//настройка SPI
	SpiaRegs.SPICCR.bit.SPICHAR = 0x7;			//передача слова из 8 бит
	SpiaRegs.SPICCR.bit.CLKPOLARITY = 1;		//подача данных на выход по спадающему фронту
	SpiaRegs.SPICTL.bit.CLK_PHASE = 0;			//выключить задержку сигнала clk
	SpiaRegs.SPIBRR = 74;						//установить частоту LSPCLK/(74+1) (1 МГц) 

	//запись в передатчик осуществляется со сдвигом на 8 разрядов влево

	//сброс микросхемы--------------------
	GpioDataRegs.GPACLEAR.all = device;				//активировать выбранное устройство
	for(i=0;i<5;i++)
		{
		SpiaRegs.SPITXBUF = y[i];					//выгрузить для передачи
		for(;!SpiaRegs.SPISTS.bit.INT_FLAG;) ;		//пока не закончилась передача, ждать	
		y[i] = SpiaRegs.SPIRXBUF;					//сохранить принятое сообщение
		}
	GpioDataRegs.GPASET.all =  (FRAM_dev_SEL +
								FLM_dev_SEL +
								EXP2_dev_SEL +
								EXP1_dev_SEL +
								ADC2_dev_SEL +
								ADC1_dev_SEL);		//выключить все устройства
	//------------------------------------
	for(i=0;i<1000;i++) {};							//задержка

	//компоновка кодов инициализации
	data[0] = (W_ad7732 + Ch1_ConvT_adr)* 0x100;		//задать адрес регистра ch convertion time
	data[1] = 0x1100;									//вывести значение в регистр

	data[2] = (W_ad7732 + Ch1_Stup_adr) * 0x100;		//задать адрес регистра setup
	data[3] = 0x0900;									//вывести значение в регистр

	data[4] = (W_ad7732 + Ch1_MODE_adr) * 0x100;		//задать адрес регистра MODE
	data[5] = 0x2000;									//вывести значение в регистр

	for(i=0;i<6;i++)	{Exch_data_SPI(device, &data[i]);}

	{//------------------------------------------------------------
	Uint16 v;
	for(v=0;v < 100;v++)
 		{
		Uint16 a, b;

		for(b=0;b < 25000;b++) {};					//задержка
		a = (W_ad7732 + Ch1_MODE_adr) * 0x100;		//задать адрес регистра MODE
		Exch_data_SPI(device, &a);
		a = 0x2000;									//вывести значение в регистр
		Exch_data_SPI(device, &a);
		}
	}//-----------------------------------------------------------  
//--------------------------------------------

}
//-------------------------------------------------------------------------


